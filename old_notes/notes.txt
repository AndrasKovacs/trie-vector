




Cached HAMT:
    - A small cache and a large array, with a bitmap for each. 

    Read : first test the cache, then the large bitmap. Lookup from the adequate one.

    Write : Test the cache
        if there, update cache
        if not there:
            if size of small array > limit 
                then copy the two arrays interleaved to new array (preferring the cache on conflict).
                new array becomes the new large array, cache becomes empty. 
                    NEEDED : find first bit instruction!!, or else it's pretty bad.
                else insert new elem into small array.   

    We need two things not in GHC currently:
        - find first set bit
        - efficient primitive array insert. 

    Goal : Implement these two :)


------------------



bytes copied per node (in postponed copy mode, with a simple list cache of lookup size 1)


branch factor | word / node copy
64  unpack    | 8  = (Cons dirty mask1 mask2 arr) + (3 word dirty insert)
128 unpack    | 10 = (Cons dirty m1 m2 m3 m4 arr) + (3 dirty insert)
256 unpack    | 14 = (Cons dirty m1..m8 arr) + (3 dirty insert)
256 packed    | 12 = (Const dirty p1 p2 arr) + (4 ptr modify) + (3 dirty insert)

branch factor | word / node copy | expected num clean access | avg copy / node (approx)
64 unpack     | 8                | 9                         | 15.2
128 unpack    | 10               | 13                        | 20
256 unpack    | 14               | 18                        | 28.3
256 packed    | 12               | 18                        | 26.5


question: what matters more, locality of bitmasks or amount of copying?
    opinion: 
        - locality is more important, esp. on bitmasks, but not as much with the dirty list.
        - 128 unpack is sweet spot in terms of copying/locality. 
        - 64 is definitely sweet spot in terms of space

USE UNBOXED whenever possible!
    I couldn't manage to do a runST that returns unboxed values.
    Nevertheless, we should just immediately pattern match the result with a wrapper and
    then proceed to only use the unboxed version. 


Use Johan Tibell et al. 's runST inlining fix. 

ht. Johann Tibell : use "return $!" 


Try 16-branching sequence with unpacked node array. (maybe 32 too?, sounds like lots of codegen)


Inserting into an array requires extra copy, because we have to initialize the new array.
    - remedy: give up bitmasks a bit earlier than full
    - find out whether having undefined pointers for a while in an Array is OK or not (it could mess up GC).
        - question: when do GC-s occur?
    - TODO: benchmark proper snoc vs. hacky snoc. 

Any pointer tricks
    - can we make gratuituous use of the Any pointer tag bits?
        - DOESN'T WORK

Immutable vector:
    - Use ArrayArray to collapse the tree
        - DOESN'T WORK



potential improv:

    dirty : 5 constructors

        C1 Int64 Node
        C2 Int64 Node Node
        C3 Int64 Node Node Node
        C4 Int64 Node Node Node Node
        C5 Int64 Node Node Node Node Node
        C6 Int64 Node Node Node Node Node Node
        Nil 

        the first Int64 contains the respective indices of the nodes


        cache size :
            1? -- super fast cache insert / lookup
            2? -- could be viable enhancement to simple list cache
            3? -- the same as with 2 
            4? 
            6? -- total 8 words : snug fit in cache line?, also 7 constructors allow for pointer tagging.
            8?
            16?

    cache: 1 constructors with simple list cons: probably good, because we avoid dereferencing the cache when there is no fault. 


    use primitive popCntWord64# instead of the function in Data.Bits (it has an additional word2Int#)
        (also, use unsafe bitshifts)


    use pointer equality when sensible
    ptr equality : if true, then leave array entry clear (nice!)

    Order the constructors by decreasing order of frequency
        source: https://hackage.haskell.org/package/containers-0.5.5.1/docs/src/Data-IntMap-Base.html#IntMap

    GHC.Prim : unpackClosure? 
        -- answer : it copies closure data to new arrays. Can't be used to modify stuff. 